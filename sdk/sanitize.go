package sdk

import (
	"reflect"

	"github.com/pkg/errors"

	"github.com/nobl9/nobl9-go/manifest"
)

// RemoveComputedFieldsFromObjects removes computed fields from each provided [manifest.Object].
// Computed fields can be:
//   - generated by Nobl9 platform when the object first is created
//   - computed each time the object is fetched from the API
//
// The original slice is modified to save computing, If you wish to prevent that,
// copy it first before passing it to this function.
//
// The function CANNOT handle [github.com/nobl9/nobl9-go/v1alpha.GenericObject]
func RemoveComputedFieldsFromObjects(objects []manifest.Object) ([]manifest.Object, error) {
	for i := range objects {
		object := objects[i]
		v := reflect.ValueOf(object)

		if (v.Kind() == reflect.Pointer && v.Elem().Kind() != reflect.Struct) ||
			(v.Kind() != reflect.Pointer && v.Kind() != reflect.Struct) {
			typ := reflect.TypeOf(objects[i])
			return nil, errors.Errorf("unsupported object kind %s at index %d, expected a struct", typ, i)
		}

		if v.Kind() != reflect.Pointer {
			ptrValue := reflect.New(v.Type())
			ptrValue.Elem().Set(v)
			v = ptrValue
			objects[i] = v.Interface().(manifest.Object)
		}

		if v.Kind() == reflect.Pointer && !v.IsNil() {
			removeComputedFields(v.Elem())
		}
	}
	return objects, nil
}

// removeComputedFields recursively removes fields tagged with nobl9:"computed".
func removeComputedFields(v reflect.Value) {
	if !v.IsValid() {
		return
	}

	switch v.Kind() {
	case reflect.Pointer:
		if !v.IsNil() {
			removeComputedFields(v.Elem())
		}
	case reflect.Struct:
		t := v.Type()
		for i := 0; i < v.NumField(); i++ {
			field := v.Field(i)
			fieldType := t.Field(i)

			if tag, ok := fieldType.Tag.Lookup("nobl9"); ok && tag == "computed" {
				// Set the field to its zero value.
				if field.CanSet() {
					field.Set(reflect.Zero(field.Type()))
				}
			} else {
				removeComputedFields(field)
			}
		}
	case reflect.Slice, reflect.Array:
		for i := 0; i < v.Len(); i++ {
			removeComputedFields(v.Index(i))
		}
	case reflect.Map:
		for _, key := range v.MapKeys() {
			removeComputedFields(v.MapIndex(key))
		}
	case reflect.Interface:
		if !v.IsNil() {
			removeComputedFields(v.Elem())
		}
	default:
		// For primitive types and other kinds, no action needed.
		return
	}
}
