package sdk

import (
	"reflect"

	"github.com/nobl9/nobl9-go/manifest"
)

// RemoveComputedFieldsFromObjects removes computed fields from each provided [manifest.Object].
// Computed fields can be:
//   - generated by Nobl9 platform when the object first is created
//   - computed each time the object is fetched from the API
func RemoveComputedFieldsFromObjects(objects []manifest.Object) []manifest.Object {
	for i := range objects {
		removeComputedFields(reflect.ValueOf(objects[i]).Elem())
	}
	return objects
}

// removeComputedFields recursively removes fields tagged with nobl9:"computed"
func removeComputedFields(v reflect.Value) {
	if !v.IsValid() || !v.CanSet() {
		return
	}

	switch v.Kind() {
	case reflect.Pointer:
		if !v.IsNil() {
			removeComputedFields(v.Elem())
		}
	case reflect.Struct:
		t := v.Type()
		for i := 0; i < v.NumField(); i++ {
			field := v.Field(i)
			fieldType := t.Field(i)

			// Check if field has nobl9:"computed" tag
			if tag, ok := fieldType.Tag.Lookup("nobl9"); ok && tag == "computed" {
				// Set the field to its zero value
				if field.CanSet() {
					field.Set(reflect.Zero(field.Type()))
				}
			} else {
				// Recursively process nested structs
				removeComputedFields(field)
			}
		}
	case reflect.Slice, reflect.Array:
		for i := 0; i < v.Len(); i++ {
			removeComputedFields(v.Index(i))
		}
	case reflect.Map:
		for _, key := range v.MapKeys() {
			removeComputedFields(v.MapIndex(key))
		}
	case reflect.Interface:
		if !v.IsNil() {
			removeComputedFields(v.Elem())
		}
	default:
		// For primitive types and other kinds, no action needed
		return
	}
}
