package e2etestutils

import (
	"fmt"
	"strings"
	"sync"
	"testing"

	"github.com/nobl9/nobl9-go/manifest"
	"github.com/nobl9/nobl9-go/manifest/v1alpha"
	v1alphaAgent "github.com/nobl9/nobl9-go/manifest/v1alpha/agent"
	v1alphaDirect "github.com/nobl9/nobl9-go/manifest/v1alpha/direct"
	v1alphaProject "github.com/nobl9/nobl9-go/manifest/v1alpha/project"
)

// DataSourcesProject is the Project which contains all the static Data Sources
// shared between different tests and their runs.
const DataSourcesProject = "e2e-data-sources"

const objectPersistedDescription = "Object generated by end-to-end tests." +
	" This object is persisted across all tests, do not delete it."

// ProvisionStaticAgent applies and returns [v1alphaAgent.Agent] of the given [v1alpha.DataSourceType].
// The Agent is meant to be persisted across test runs.
func ProvisionStaticAgent(t *testing.T, typ v1alpha.DataSourceType) v1alphaAgent.Agent {
	t.Helper()

	cacheKey := staticDataSourcesKey(manifest.KindAgent, typ)
	if agent, ok := staticAgentsCache.Load(cacheKey); ok {
		return agent
	}

	staticAgentsCache.Lock()
	defer staticAgentsCache.Unlock()
	if cached, ok := staticAgentsCache.LoadUnsafe(cacheKey); ok {
		return cached
	}
	agent := getStaticAgent(t, typ)
	V1Apply(t, []manifest.Object{getDataSourcesProject(), agent})
	staticAgentsCache.StoreUnsafe(cacheKey, agent)
	return agent
}

// ProvisionStaticDirect applies and returns [v1alphaDirect.Direct] of the given [v1alpha.DataSourceType].
// The Direct is meant to be persisted across test runs.
func ProvisionStaticDirect(t *testing.T, typ v1alpha.DataSourceType) v1alphaDirect.Direct {
	t.Helper()
	if !v1alphaDirect.IsValidDirectType(typ) {
		t.Fatalf("Direct does not support %[1]s %[1]T", typ)
	}

	cacheKey := staticDataSourcesKey(manifest.KindAgent, typ)
	if direct, ok := staticDirectsCache.Load(cacheKey); ok {
		return direct
	}

	staticDirectsCache.Lock()
	defer staticDirectsCache.Unlock()
	if cached, ok := staticDirectsCache.LoadUnsafe(cacheKey); ok {
		return cached
	}
	direct := getStaticDirect(t, typ)
	V1Apply(t, []manifest.Object{getDataSourcesProject(), direct})
	staticDirectsCache.StoreUnsafe(cacheKey, direct)
	return direct
}

// staticAgentsCache is used to store already applied static data sources.
// This way we do not execute unnecessary 'apply' requests.
var (
	staticAgentsCache  = newMapCache[string, v1alphaAgent.Agent]()
	staticDirectsCache = newMapCache[string, v1alphaDirect.Direct]()
)

func staticDataSourcesKey(kind manifest.Kind, typ v1alpha.DataSourceType) string {
	return kind.String() + ":" + typ.String()
}

func getStaticAgent(t *testing.T, typ v1alpha.DataSourceType) v1alphaAgent.Agent {
	t.Helper()

	example := GetExample(t, manifest.KindAgent, FilterExamplesByDataSourceType(typ))
	agent := example.GetObject().(v1alphaAgent.Agent)
	agent.Metadata = v1alphaAgent.Metadata{
		Name:    fmt.Sprintf("e2e-agent-%s", strings.ToLower(typ.String())),
		Project: DataSourcesProject,
	}
	agent.Spec.Description = objectPersistedDescription

	return agent
}

func getStaticDirect(t *testing.T, typ v1alpha.DataSourceType) v1alphaDirect.Direct {
	t.Helper()

	example := GetExample(t, manifest.KindDirect, FilterExamplesByDataSourceType(typ))
	direct := example.GetObject().(v1alphaDirect.Direct)
	direct.Metadata = v1alphaDirect.Metadata{
		Name:    fmt.Sprintf("e2e-direct-%s", strings.ToLower(typ.String())),
		Project: DataSourcesProject,
	}
	direct.Spec.Description = objectPersistedDescription

	return direct
}

func getDataSourcesProject() v1alphaProject.Project {
	return v1alphaProject.New(
		v1alphaProject.Metadata{
			Name:        DataSourcesProject,
			DisplayName: "End-to-end Data Sources",
			Labels: v1alpha.Labels{
				"origin": []string{"e2e-test"},
			},
		},
		v1alphaProject.Spec{
			Description: "This Project contains a collection of all Agent and Direct types used for end-to-end tests." +
				" This Project along with all its associated objects is meant to be persisted across test runs" +
				" in order to speed up the execution of other tests, primarily targeting SLOs.",
		},
	)
}

func newMapCache[K comparable, T any]() *mapCache[K, T] {
	return &mapCache[K, T]{storage: make(map[K]T)}
}

type mapCache[K comparable, T any] struct {
	storage map[K]T
	sync.RWMutex
}

// Load must be called OUTSIDE critical section.
func (m *mapCache[K, T]) Load(key K) (T, bool) {
	m.RLock()
	defer m.RUnlock()
	v, ok := m.storage[key]
	return v, ok
}

// LoadUnsafe must be called INSIDE critical section.
func (m *mapCache[K, T]) LoadUnsafe(key K) (T, bool) {
	v, ok := m.storage[key]
	return v, ok
}

// StoreUnsafe must be called INSIDE critical section.
func (m *mapCache[K, T]) StoreUnsafe(key K, v T) {
	m.storage[key] = v
}
