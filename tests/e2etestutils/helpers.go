package e2etestutils

import (
	"errors"
	"fmt"
	"net/url"
	"os"
	"runtime"
	"strconv"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/require"
	"golang.org/x/sync/errgroup"

	"github.com/nobl9/nobl9-go/manifest"
	"github.com/nobl9/nobl9-go/manifest/v1alpha"
	"github.com/nobl9/nobl9-go/sdk"
)

// GenerateName generates a unique name for the test object.
func GenerateName() string {
	return fmt.Sprintf("%s-e2e-%d-%d", strings.ToLower(toolName), objectsCounter.Add(1), testStartTime.UnixNano())
}

// GetObjectDescription returns a unified [manifest.Object] description.
func GetObjectDescription() string {
	return fmt.Sprintf("Object generated by %s end-to-end tests", toolName)
}

// AnnotateLabels adds origin label to the provided labels,
// so it's easier to locate the leftovers from these tests.
// It also adds unique test identifier label to the provided labels
// so that we can reliably retrieve objects created within a given test.
func AnnotateLabels(t *testing.T, labels v1alpha.Labels) v1alpha.Labels {
	t.Helper()
	if labels == nil {
		labels = make(v1alpha.Labels, 3)
	}
	labels["origin"] = []string{"e2e-test"}
	labels["tool"] = []string{toolName}
	labels[getUniqueTestIDLabelKey()] = []string{""}
	labels["test-name"] = []string{t.Name()}
	return labels
}

// V1Apply applies all the provided [manifest.Object].
func V1Apply[T manifest.Object](t *testing.T, objects []T) {
	t.Helper()
	v1ApplyOrDeleteBatch(t, generifyObjects(objects), apiOperationApply, len(objects)+1)
}

// V1Delete deletes all the provided [manifest.Object].
func V1Delete[T manifest.Object](t *testing.T, objects []T) {
	t.Helper()
	v1ApplyOrDeleteBatch(t, generifyObjects(objects), apiOperationDelete, len(objects)+1)
}

// V1ApplyBatch applies all the provided [manifest.Object] in batches of the provided size.
func V1ApplyBatch[T manifest.Object](t *testing.T, objects []T, batchSize int) {
	t.Helper()
	v1ApplyOrDeleteBatch(t, generifyObjects(objects), apiOperationApply, batchSize)
}

// V1DeleteBatch deletes all the provided [manifest.Object] in batches of the provided size.
func V1DeleteBatch[T manifest.Object](t *testing.T, objects []T, batchSize int) {
	t.Helper()
	v1ApplyOrDeleteBatch(t, generifyObjects(objects), apiOperationDelete, batchSize)
}

type apiOperation int

const (
	apiOperationApply apiOperation = iota
	apiOperationDelete
)

// v1ApplyOrDeleteBatch applies or deletes objects in batches.
// The batch size is determined by the batchSize parameter.
// The operations on each batch are executed concurrently.
func v1ApplyOrDeleteBatch(
	t *testing.T,
	objects []manifest.Object,
	operation apiOperation,
	batchSize int,
) {
	t.Helper()
	group, ctx := errgroup.WithContext(t.Context())
	group.SetLimit(runtime.NumCPU())
	for i, j := 0, 0; i < len(objects); i += batchSize {
		j += batchSize
		if j > len(objects) {
			j = len(objects)
		}
		batch := objects[i:j]
		group.Go(func() error {
			applyAndDeleteLock.Lock()
			defer applyAndDeleteLock.Unlock()
			switch operation {
			case apiOperationApply:
				return sdkClient.Objects().V1().Apply(ctx, batch)
			case apiOperationDelete:
				return sdkClient.Objects().V1().Delete(ctx, batch)
			default:
				return errors.New("invalid API operation")
			}
		})
	}
	err := group.Wait()
	var urlErr *url.Error
	if errors.As(err, &urlErr) && urlErr.Timeout() {
		// Unlock the lock to allow other tests to proceed,
		// including the retry, which otherwise would cause a deadlock.
		applyAndDeleteLock.Unlock()

		waitFor := 30 * time.Second
		t.Logf("timeout encountered, the apply/delete operation will be retried in %s; test: %s; error: %v",
			waitFor, t.Name(), err)
		time.Sleep(waitFor)
		v1ApplyOrDeleteBatch(t, objects, apiOperationDelete, batchSize)
	} else {
		require.NoError(t, err)
	}
}

type noopLocker struct{}

func (n noopLocker) Lock()   {}
func (n noopLocker) Unlock() {}

func newApplyAndDeleteLocker() sync.Locker {
	sequential, _ := strconv.ParseBool(os.Getenv(sdk.EnvPrefix + "TEST_RUN_SEQUENTIAL_APPLY_AND_DELETE"))
	if sequential {
		fmt.Println("Running apply and delete operations sequentially")
		return new(sync.Mutex)
	}
	return noopLocker{}
}

func generifyObjects[T manifest.Object](objects []T) []manifest.Object {
	result := make([]manifest.Object, len(objects))
	for i := range objects {
		result[i] = objects[i]
	}
	return result
}
